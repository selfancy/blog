# Java面试题合集 <!-- {docsify-ignore-all} -->

## TCP/UDP的区别？[链接](https://www.php.cn/faq/463414.html)
![](https://img.php.cn/upload/image/183/308/585/1605056951790214.png)

## TCP断开链接为什么需要四次握手，三次行不行？[链接](https://blog.csdn.net/qq_40843865/article/details/103989969)

- 第一次挥手：client告诉server自己的数据已全部发送，client可以回收发送缓冲区，server可以回收接收缓冲区
- 第二次挥手：server告诉client自己收到了关闭信息
- 第三次挥手：server告诉client自己的数据已全部发送，server可以回收发送缓冲区，client可以回收接收缓冲区
- 第四次挥手：client告诉server自己收到了关闭信息
  任何一次都不能少，如果少了其中任何一次，总有一方不能可靠的通知对方自己的数据已发送完毕，因此，连接不可能可靠的断开，TCP也就成了不可靠的协议。

## TCP协议如何保证可靠传输？[链接](https://www.likecs.com/show-204117331.html)

## TCP流量控制？如果接收方窗口内有数据帧丢失怎么办？接收方如何保证数据有序？
- [TCP流量控制](https://blog.csdn.net/qq_44005483/article/details/117127099)
- [TCP的滑动窗口以及包丢失的重传问题](https://blog.csdn.net/qq_43669007/article/details/105440492)
- [TCP如何保证消息顺序](https://blog.csdn.net/TABE_/article/details/123583991)

**为什么要控制流量？**

一般来说我们希望数据传输的速度能够更快一些
但是如果发送方把数据发送的太快，接收方可能来不及接收，这就会造成数据的丢失
流量控制就是让发送方的发送速度不要过快，要让接收方来得及接收
TCP协议通过滑动窗口机制实现对TCP连接的流量控制

**TCP流量控制总结**

接收方主机根据自己的接收窗口大小，控制发送方的发送窗口大小，发送方发送窗口内的数据全部发送后，在没有收到ACK确认报文，不会发送新的数据。丢失的数据包会超时重传，发送方收到零窗口通知时会启动持续计时器，超时后会发送零窗口探测报文，以次获取接收方的窗口值大小，保证数据传输。

## TCP数据包丢失怎么办？
- 1、数据分片：发送端对数据进行分片，接受端要对数据进行重组，由TCP确定分片的大小并控制分片和重组
- 2、到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认
- 3、超时重发：发送方在发送分片时设置超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片数据
- 4、滑动窗口：TCP连接的每一方的接受缓冲空间大小固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出
- 5、失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层;
- 6、重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据;
- 7、数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验或有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发

## 进程和线程的区别？[链接](https://blog.csdn.net/weixin_42981419/article/details/86162071)
进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）

线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）

## 进程间的通信方式？[链接](https://blog.csdn.net/weixin_42981419/article/details/86162071)
- 1、管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
- 2、信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
- 3、消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
- 4、共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
- 5、信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
- 6、套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 线程任务调度算法？
**1、时间片轮转调度算法（RR）：**

给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。

优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。

**2、先来先服务调度算法（FCFS）：**

根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，

优点是公平，实现简单；缺点是不利于短作业。


**3、优先级调度算法（HPF）：**

在进程等待队列中选择优先级最高的来执行。

**4、多级反馈队列调度算法：**

将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。

优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。

**5、高响应比优先调度算法：**

根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。

优点是兼顾长短作业；缺点是计算响应比开销大，适用于批处理系统。

## 磁盘工作原理？[链接](https://blog.csdn.net/qq_38526635/article/details/84249674)

## 操作系统为什么要执行fsync命令?如果不用fsync命令怎么刷盘？
sync命令的作用是”清空文件系统缓冲区”,就是强制将内存中文件系统的缓存信息存储到物理介质(硬盘等)中。

Linux内核为了达到最佳的磁盘操作效率，会把需要写入到磁盘的数据先在内存中缓存起来，在合适的时候才真正写入到磁盘中，这在绝大多数情况都是没有任何问题的，而且提高了系统的效率，但是如果系统当机、掉电，有些文件的容就会丢失。

在暂停系统之前，比如要重新启动机器，一定要去执行sync命令。unix系统运行经验表明，为确保可靠起见，应执行两遍sync命令，这是因为sync命令完成时，并不保证信息实际写到了磁盘上，虽然已经执行了一遍这个命令。在执行sync命令以后，要等待磁盘工作灯灭了（假定有系统工作指示灯的话），再去真正暂停机器的运行或启动机器。

命令sync来写入所有文件，fsync来保存某个文件。

## 线程池大小设置多少，根据什么考虑的？
通常根据任务来考虑的，类型一般是：CPU密集型、IO密集型、混合型，对不同类型的任务我们就需要分配不同大小的线程池
**1、CPU密集型**

这种任务我们要尽量使用较小的线程池，一般是Cpu核心数+1

因为CPU密集型任务CPU的使用率很高，若开过多的线程，只能增加线程上下文的切换次数，带来额外的开销

**2、IO密集型**

方法一：可以使用较大的线程池，一般CPU核心数 * 2

IO密集型CPU使用率不高，可以让CPU等待IO的时候处理别的任务，充分利用cpu时间

方法二：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

下面举个例子：

例如：平均每个线程CPU运行时间为0.5s，而线程等待时间(非CPU运行时间，比如IO)为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为：

最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1)* CPU数目

**3、混合型**

是一种可以将任务分为CPU密集型和IO密集型，然后它可以分别使用不同的线程池去处理，按情况而定。

## 无锁阻塞队列如何实现？
- 链表实现
- 数组实现

[无锁队列解决了什么问题？无锁队列的实现](https://zhuanlan.zhihu.com/p/492214546)

[无锁队列的实现](https://blog.csdn.net/Wekic/article/details/74035038)

## Java线程间如何通信说出你知道的所有方法？[链接](https://blog.csdn.net/aaa_hao/article/details/123685742)
- 1、锁与同步
- 2、等待/通知机制
- 3、信号量
- 4、管道
- 5、其它通信相关
    - 5.1 join() 方法
    - 5.2 sleep() 方法，sleep() 与 wait() 的区别
    - 5.3 ThreadLocal 类
    - 5.4 InheritableThreadLocal

## 哈希表 如何实现的？[链接](https://blog.csdn.net/qq_29346449/article/details/51910439)

## 布隆过滤器如何实现的，为什么需要多个hash函数，有多少个bitmap实现的？
[布隆过滤器的原理、使用场景、注意事项以及bitMap实现](https://blog.csdn.net/Dawn510/article/details/105300551)

[布隆过滤器为什么要用多个hash函数操作同一个bitmap?](https://www.zhihu.com/question/452746903/answer/2210220726)

## 编程题：
- 一个人可以搬一个或者俩个板凳，将n个板凳从A地方搬到B地方一共有几种方式？
- 一副扑克牌有四种桃色，每个桃色13张牌，按固定桃色顺序取四张牌，一共有多少种排列组合？

## spring的理解？对springboot的理解？为什么有spring还要有springboot？
**为什么有spring还要有springboot?**

- 简便，Spring Boot可以快速通过引导式的步骤搭建一个生产级企业应用开发平台，而无需繁琐的配置。而且提供了默认配置，甚至你可以达到零配置接入。
- 灵活，Spring Boot同时对常用的功能进行了组件化的抽象，可以按需引用。另外也指定了一揽子的组件规范让开发者可以自行实现符合 Spring Boot 风格的组件（Starter），让你实现插件化开发。
- 集中，每一个版本的依赖都经过测试和挑选，对各个组件进行了集中管理，构成一个 parent 集合，减少了依赖冲突的可能性。
- 敏捷，Spring Boot通过一些注解简化了之前的开发和配置，减少了模板代码的编写，加快了开发速度。内置Web 容器甚至可以以 Jar 的方式快速部署运行。

## springboot自动配置？

## 依赖注入是什么？
**什么是依赖注入？**

就是把有依赖关系的类放到容器中,然后解析出这些类的实例，就是依赖注入。目的是实现类的解耦。

构造注入，接口注入，setter注入

## jdk8——stream流理解？lamda底层实现？
**lamda底层实现？**

通过执行LambdaMetafactory.metafactory创建出CallSite，进而创建出Lambda表达式对应的对象的，把对应的函数式接口与具体实现中的代码的关联

## NIO是什么？优点是什么？底层实现？
[NIO的基本介绍](https://blog.csdn.net/weixin_43732955/article/details/116426372)

**一、什么是NIO**

- Java NIO全称java non-blocking IO， 是指JDK提供的新API。从JDK1.4开始，Java提供了一系列改进的输入/输出的新特性，被统称为NIO(即New IO)，是同步非阻塞的
- NIO有三大核心部分: Channel(通道)， Buffer(缓冲区),Selector(选择器)
- NIO是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。

**二、NIO 与BIO 模型对比**

- BIO 是同步阻塞IO,服务器的模式是一个线程处理一个请求，当无响应时，会阻塞线程
- NIO 同步非阻塞IO,会有一个Selector管理多个线程，当有事件发生后，进行处理、不会发生阻塞
  nio是依赖操作系统的实现是，是基于IO复用技术的非阻塞IO；其中Selctor的实现，底层使用epoll替换了select/poll。

## 对反射理解？反射有什么缺点？
[java反射机制的优点和缺点](https://blog.csdn.net/hongfenglx/article/details/108819006)

**反射机制的缺点**
尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点：
- 1、性能问题。Java反射机制中包含了一些动态类型，所以Java虚拟机不能够对这些动态代码进行优化。因此，反射操作的效率要比正常操作效率低很多。我们应该避免在对性能要求很高的程序或经常被执行的代码中使用反射。而且，如何使用反射决定了性能的高低。如果它作为程序中较少运行的部分，性能将不会成为一个问题。
- 2、安全限制。使用反射通常需要程序的运行没有安全方面的限制。如果一个程序对安全性提出要求，则最好不要使用反射。
- 3、程序健壮性。反射允许代码执行一些通常不被允许的操作，所以使用反射有可能会导致意想不到的后果。反射代码破坏了Java程序结构的抽象性，所以当程序运行的平台发生变化的时候，由于抽象的逻辑结构不能被识别，代码产生的效果与之前会产生差异。

## 浮点数和定点数有什么区别？底层实现？
定点表示法运算直观，但数的表示范围较小，不同的数运算时要考虑比例因子的选取，以防止溢出。

浮点表示法运算时可以不考虑溢出，但浮点运算，编程较难。要掌握定、浮点数的转换方法及浮点数规格化方法。

[浮点数的底层原理](https://blog.csdn.net/feng_926701/article/details/108836898)

[浮点数的底层原理和精度损失问题](https://zhuanlan.zhihu.com/p/269619376)

## 对多态的理解？
对扩展开放，对修改封闭

## 数组和 链表 在内存中的存储？
- 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。
- 链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。

## 对二分的理解？ 链表可以二分吗？
在单调递增（减）条件下，可以快速查找一个需要的数字。常用于：在时间最小的情况下（二分时间），在最长边最短的情况下（二分长度 ）

链表不适合用二分，因为链表的每一个节点的地址不能在O(1)的时间复杂度内获得

[二分查找为什么不能用于链表？](https://www.zhihu.com/question/65442385)

## 对 二叉树 理解？对 红黑树 理解？为什么使用 红黑树 ，不使用 平衡二叉树 ？
因为插入删除会锁结构，就会导致性能下降，而红黑树由于其原理上，在插入和删除数据之后，旋转上色的过程比较少，所以锁结构的时间短，性能更佳。这也是Redis的底层结构，JDK里面的各种Map大多都是采取的红黑树就是这个原理。

平衡二叉树的选择过程是递归的，旋转一次会导致后续的又不平衡了，所以在删除和插入节点时，为了使得该树再次平衡而带来的旋转操作就比较多。

## 红黑树解决了什么问题?
平衡二叉树: 就是为了防止二叉搜索树变为线性数据结构,而出现的数据结构.而AVL树-绝对平衡树.左右子树的高度差不能超过1

**红黑树特性**

- 1.每个结点不是红色就是黑色
- 2.根节点:一定是黑色的
- 3.不可能有两个红色的节点连在一起,每个叶子节点都是黑色的空节点(NIl),并且不存储数据
- 4.每个节点,从该结点到达其可到达的叶子节点的所有路径,都包含相同树目的黑色节点

***为什么要用红黑树***

三个操作

- 1.变色
- 2.左旋: 指针的变化
- 3.右旋:指针的变化

什么时候左旋?什么时候右旋呢?

所有新加的点一定是红色

红黑树建立的基础就是在二叉查找树的基础之上的.解决了二叉查找树的线性问题;进行平衡性;


## 什么是b树？磁盘IO为什么慢？什么是b+树？相比b树优点？
B树是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。

B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。

**B树结构：**


如果数据量较大时，会导致每个节点能存储的key的数量变少，同样会导致B树的深度较大，增大查询时的磁盘IO次数

**B+树结构：**


所有数据都按照键值大小顺序放在同一层的叶子节点上，并且所有相邻的叶子节点使用链表进行连接，不再需要中序遍历。

非叶子节点上只存储key值信息，这样大大加大每个节点存储的key值数量，降低B+树的高度

## 操作系统从用户态转换为系统态干了什么？
[操作系统中用户态和内核态（系统态）是什么？用户态如何变成内核态？](https://blog.csdn.net/qq_41963899/article/details/108868704)

## mysql底层数据结构？
- 1.索引
    - 本质也是一种数据结构.是一种排好序的数据结构
    - 索引数据结构
        - 二叉树
        - 红黑树
        - hash表
        - b_Tree
        - b+Tree
- MyISAN

## 对synchronized 的理解？底层实现？
**理解synchronized的含义**

1、synchronized就是给当前的NumOps类型的对象添加了一个互斥锁机制:锁只能有一个

2、当有一个线程正在某个同步方法中执行，则其它线程不能进入该对象的任何同步方法中,可以进入非同步方法

底层实现：使用synchronized加锁的字节码会出现monitor-enter和monitor-exit两个指令，可以理解为代码块执行前的加锁，和退出同步时的解锁

## redis 和mysql的一个单点查询请求的延迟大概在什么量级？

## jvm运行时区域？
- 程序计数器
- 虚拟机栈
    - 栈的存储单位：栈的存储单位为栈帧，线程上正在执行的一个方法对应一个栈帧，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
    - 栈帧的内部结构：每个栈帧包含五部分，分别包括局部变量表(方法参数、各种基本数据类型、对象引用)、操作数栈、动态链表（指向运行时常量池的方法引用）、方法返回地址和一些附加信息。
- 本地方法栈
- 堆

![](https://img-blog.csdnimg.cn/097a6823fcee4254aaa8517a49bfddae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Za15Za16LaF54mb,size_20,color_FFFFFF,t_70,g_se,x_16)

## 虚拟机栈有什么？栈帧？方法参数存在虚拟机栈还是栈帧？
- 虚拟机栈
    - 栈的存储单位：栈的存储单位为栈帧，线程上正在执行的一个方法对应一个栈帧，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
    - 栈帧的内部结构：每个栈帧包含五部分，分别包括局部变量表(方法参数、各种基本数据类型、对象引用)、操作数栈、动态链表（指向运行时常量池的方法引用）、方法返回地址和一些附加信息。

## 垃圾回收算法？各自的优缺点？
[垃圾回收策略和算法，看这篇就够了](https://baijiahao.baidu.com/s?id=1674235021824640450&wfr=spider&for=pc)

**1、标记-清理法**

在GC时候，先进行扫描，把需要清理的无用对象进行标记，然后将这些对象直接清理

优点：实现简单，与保守式 GC 算法兼容

缺点：标记和清除的效率不高，会产生大量内存碎片

**2、GC标记-整理算法（老年代采用的方式）**

在标记-清理的基础上，清理完成后，将内存空间进行整理，使空间紧凑排列，解决了内存碎片的问题，它在进行垃圾回收时,必须暂停所有用户线程,直到它收集结束

优点：堆利用效率高

缺点：压缩花费计算成本

**3、GC复制法（新生代采用的方式）**

将空间一分为二，在清理时，将需要保留的对象复制到第二块区域上，复制的时候直接紧凑排列，然后把原来的一块区域清空

优点：优秀的吞吐量，可实现高速分配，不会发生碎片化，与缓存兼容

缺点：堆使用效率低下，不兼容保守式 GC 算法，递归调用函数消耗栈可能导致栈溢出

**4、引用计数法**

优点：可即刻回收垃圾，最大暂停时间短，没有必要沿指针查找

缺点：计数器值的增减处理繁重，计数器需要占用很多位，实现烦琐复杂，循环引用无法回收

**5、保守式 GC**

简单来说，保守式 GC(Conservative GC)指的是“不能识别指针和非指针的 GC”。

优点：语言处理程序不依赖于 GC

缺点：识别指针和非指针需要付出成本，错误识别指针会压迫堆，能够使用的 GC 算法有限

**6、分代垃圾回收**

优点：吞吐量得到改善

缺点：识别指针和非指针需要付出成本，错误识别指针会压迫堆，能够使用的 GC 算法有限

## 垃圾回收时，哪种算法回收时，我们不能执行用户线程？
GC标记-整理算法（老年代采用的方式）

## 年轻代，老年代都用什么算法 ？
- 年轻代：GC复制算法
- 老年代：GC标记-整理算法

## 一个项目的构建流程？

## tcp是什么？什么是连接？为什么要有连接？

## 网络读的过程？
涉及用户态到内核态的切换

涉及用户态->内核态和内态核->用户态的切换

## 1.三握四挥，没收到确认怎么办，从操作系统的底层角度分析（不会）

## 2.HashMap源码
jdk1.8以前是数组+链表

jdk1.8以后是数组+链表+红黑色
## 3.springboot的starter

## 4.学过计组吧？（早忘干净了）说说volatile为什么不能保证原子性，从cpu缓存的角度分析
[volatile为什么不能保证原子性？](https://www.zhihu.com/question/329746124)

## 5.向数据库插入数据，从底层分析经历哪些流程
![SQL的执行过程](https://c1.lmlphp.com/user/master/2021/02/18/son_1/aa6f98818eaa462cca86962bab156ef3.png)

[MYSQL查询和插入数据的流程是怎样的](https://www.lmlphp.com/user/1436/article/item/591565/)
## 6.mysql隔离级别，mvcc
**事务具有四个特征**

原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（
Durability ）。这四个特性简称为 ACID 特性。

**Mysql的四种隔离级别**
[MySQL四种隔离级别](https://blog.csdn.net/zhouqi1427/article/details/117658914)

低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

Read Uncommitted（读取未提交内容）
> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。
> 读取未提交的数据，也被称之为脏读（DirtyRead）。

Read Committed（读取提交内容）
> 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
> 这种隔离级别 也支持所谓的不可重复读（Nonrepeatable
Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

Repeatable Read（可重复读）
> 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。
> 简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。
> InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion ConcurrencyControl）机制解决了该问题。

Serializable（可串行化）
> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如

- 脏读(DrityRead)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatableread):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(PhantomRead):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。

![](https://img-blog.csdnimg.cn/20210607134851953.png)


## 7.计算 链表 环的长度
[链表-求链表环的长度](https://blog.csdn.net/weixin_42146769/article/details/88430572)

## 一面：
## 1. 自我介绍，聊项目内容
## 2. Java开发当中有使用到哪些数据类型？
## 3. HashMap类型put和get的底层实现？ 链表过长会怎么处理？转换为 红黑树 有什么好处？
[HashMap put操作，链表长度超过8，不一定会转化为红黑树！！！](https://blog.csdn.net/Elliot_Elliot/article/details/115758703)

## 4. HashMap是不是线程安全的？多线程下可能会带来什么问题？
- 丢失元素
- 多线程同时扩容会导致循环链表

## 5. ArrayList的特点？如果要从列表的中间添加元素是怎么实现的，和LinkedList相比有什么不同？
[ArrayList和LinkedList有什么区别（看完必懂）](https://blog.csdn.net/deng624796905/article/details/103198114)

## 6. 假如我在List中要找到指定值的元素，ArrayList和LinkedList查找的时间复杂度？
**ArrayList是线性表（数组）**

- get（）直接读取几个下标，时间复杂度O（1）
- add（index，E）添加元素，其后元素需要移动，复杂度O（n）
- remove（）删除元素，其后元素逐个移动，复杂度O（n）

**LinkedList是链表**

- get（）获取第几个元素，依次遍历，复杂度O（n）
- add（index，E）添加元素，修改前后元素的next和previous节点，复杂度O（1）
- remove（）删除元素，直接指向指针操作，复杂度O（1）
-
## 7. 对锁有了解没，synchronized和ReenterantLock的区别？了解过读写锁没有？
[synchronized与ReenterantLock的比较](https://blog.csdn.net/qq_26222859/article/details/80602793)

## 8. 说一下线程池的参数，工作线程数怎么变化的？有自己写过拒绝策略没有？
``` java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
}
 
 /**
	 1、corePoolSize线程池中的常驻核心线程数
	 2、maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值大于等于1
	 3、keepAliveTime:多余的空闲线程存活时间，当空间时间达到keepAliveTime值时，多余的线程会被销毁 
	   直到剩下corePoolSize个线程为止。
	 
	   默认情况下:只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程 
	   数不大于corepoolSIze。
	 4、Unit：keepAliveTime的单位
	 5、WorkQueue：任务队列，被提交但尚未被执行的任务
	 6、ThreadFactory：表示生成线程池中工作线程的线程工厂，用户创建新线程，一搬用默认即可
	 7、Handler：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大线程数 
	   （maximumPoolSize）时如何来拒绝请求执行的runnable的策略
 **/
 
```
## 9. AtomicInteger之类的原子类型用到过没？CAS存在什么缺陷？
CAS的缺点有如ABA问题，自旋锁消耗问题、多变量共享一致性问题.

**1.ABA：**

问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。
解决方法：CAS还是类似于乐观锁，同数据乐观锁的方式给它加一个版本号或者时间戳，如AtomicStampedReference

**2.自旋消耗资源：**

问题描述：多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。
解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。
虽然base和cells都是volatile修饰的，但感觉这个sum操作没有加锁，可能sum的结果不是那么精确。

**3.多变量共享一致性问题：**

解决方法： CAS操作是针对一个变量的，如果对多个变量操作

- 1.可以加锁来解决。
- 2.封装成对象类解决。

## 10. 最近有主动了解什么新技术没？学习技术的途径？
## 11. redis 的数据类型？zset的数据结构？
```
string --> String
hash --> Hashmap
list --> LinkList
set --> HashSet
sorted_set --> TreeSet
```

zset(sorted set-有序集合),其主要作用用于排行榜实现，你可以获取排名第几到第几的数据


**zset数据结构**

sorted set-有序集合在redis中有两种实现

- 1.ziplist，压缩双向链表,相关链接

- 2.skiplist,跳表实现

## 12. Redis的持久化方式？在实际项目是怎么用 redis 的？
[redis 持久化的两种方式](https://blog.csdn.net/cwl_0514/article/details/105752036)

- RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。
- AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。

## 1. 说一下rsa和aes的底层原理？
[常见加密算法DES、AES和RSA的原理和特点](https://baijiahao.baidu.com/s?id=1687921257620518892&wfr=spider&for=pc)

## 2. redis 执行decryby命令是单线程的吗？
单线程

## 用过什么数据类型? mysql为什么用b+树实现索引?b+树有这些优势，为什么mongodb用b树?
## 手写代码:给定100张票，用多线程实现一个抢票程序
## 优化:不用锁机制怎么实现?
## mysql的优化器机制
[MySQL优化原理](https://blog.csdn.net/qq_15427331/article/details/123228836)
[Mysql优化器原理](https://blog.csdn.net/taoerchun/article/details/121376459)

## 设计模式知道哪些?工厂模式有哪几种

## 2，B树与B+树，为什么用B+树而不用B树，为什么B+树效率比B树高（模拟两可的回答）
[B+树比B树更快的原因](https://blog.csdn.net/jinking01/article/details/115506194)

## 3，tcp协议，三次链接，与四次断开连接，滑动窗口
[TCP三次握手和四次挥手/滑动窗口](https://blog.csdn.net/weixin_46211877/article/details/112758051)

**滑动窗口**

主要作用: 滑动窗口主要是进行流量控制的


